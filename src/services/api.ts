
import { ControlMapping, TemplateData, ApiResponse } from '../types';

// This is a mock implementation for the frontend
// In a real app, these would connect to actual backend endpoints

export const parseChartData = async (
  data: FormData | { text: string; synthName: string }
): Promise<ApiResponse<ControlMapping[]>> => {
  try {
    console.log('Parsing chart data:', data);
    
    let textContent = "";
    let synthNameValue = "";
    
    // Extract text content and synth name from different data formats
    if (data instanceof FormData) {
      synthNameValue = data.get('synthName') as string;
      
      const fileData = data.get('file');
      const textData = data.get('text');
      
      if (fileData instanceof File) {
        // In a real implementation, we'd process the file here
        // For now, we'll use the OpenAI API to parse the text content
        textContent = "This is a placeholder for PDF content that would be extracted.";
      } else if (textData) {
        textContent = textData as string;
      }
    } else {
      textContent = data.text;
      synthNameValue = data.synthName;
    }
    
    if (!textContent.trim() && !synthNameValue.trim()) {
      throw new Error("Missing input data. Please provide either text or a file to parse, and a synthesizer name.");
    }
    
    // Call OpenAI API to parse the text content
    try {
      // In a real backend implementation, this would use:
      // import os
      // from dotenv import load_dotenv
      // load_dotenv()
      // key = os.getenv("OPENAI_API_KEY")
      // if not key:
      //     raise HTTPException(status_code=500, detail="OpenAI API key not configured")

      // Simulate API processing time
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Mock response with sample mappings - in real implementation this would be the OpenAI API response
      const mockControls: ControlMapping[] = [
        { name: "Cutoff", cc: 74, type: "pot" },
        { name: "Resonance", cc: 71, type: "pot" },
        { name: "Attack", cc: 73, type: "pot" },
        { name: "Decay", cc: 75, type: "pot" },
        { name: "Sustain", cc: 76, type: "pot" },
        { name: "Release", cc: 72, type: "pot" },
        { name: "LFO Rate", cc: 77, type: "pot" },
        { name: "LFO Amount", cc: 78, type: "pot" },
        { name: "Filter Env", cc: 79, type: "pot" },
        { name: "Osc Mix", cc: 70, type: "fader" },
        { name: "Volume", cc: 7, type: "fader" },
        { name: "Pan", cc: 10, type: "fader" },
        { name: "Delay Send", cc: 91, type: "fader" },
        { name: "Reverb Send", cc: 94, type: "fader" },
        { name: "Note On", cc: 80, type: "pad" },
        { name: "Note Off", cc: 81, type: "pad" },
      ];
      
      return { success: true, data: mockControls };
    } catch (error) {
      console.error("API error:", error);
      
      // Handle specific error for missing API key
      if (error instanceof Error && error.message.includes("OpenAI API key not configured")) {
        return {
          success: false,
          error: "Server configuration error: OpenAI API key not configured"
        };
      }
      
      return { 
        success: false, 
        error: error instanceof Error ? error.message : "Failed to parse chart data. Please check your input and try again."
      };
    }
  } catch (error) {
    console.error("Error parsing chart data:", error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : "Failed to parse chart data. Please check your input and try again."
    };
  }
};

export const buildTemplate = async (
  templateData: TemplateData
): Promise<Blob> => {
  try {
    console.log('Building template with data:', templateData);
    
    // Simulate API processing time
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Create a mock .syx file (just a small binary blob for demonstration)
    // In a real app, this would be actual sysex data from your backend
    const mockSyxData = new Uint8Array([
      0xF0, 0x00, 0x20, 0x29, 0x01, 0x42, 0x12, 
      // Add more bytes to simulate a more realistic SysEx file
      0x00, 0x01, 0x00, 0x00, 0x02, 0x03, 0x04,
      // Add more bytes... in a real implementation this would be generated by the backend
      0xF7 // SysEx end byte
    ]);
    
    // Return as Blob with the correct MIME type
    return new Blob([mockSyxData], { type: 'application/octet-stream' });
  } catch (error) {
    console.error("Error building template:", error);
    throw new Error(error instanceof Error ? error.message : "Failed to build template");
  }
};

export const downloadTemplate = (blob: Blob, synthName: string) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${synthName.replace(/[^a-zA-Z0-9]/g, '_')}_Template.syx`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
